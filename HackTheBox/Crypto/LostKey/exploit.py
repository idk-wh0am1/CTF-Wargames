from sage.all import *
from Crypto.Util.number import *
from hashlib import sha1
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

def decrypt(key, iv, ct):
    iv = bytes.fromhex(iv)
    key = sha1(str(key).encode('ascii')).digest()[0:16]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return cipher.decrypt(bytes.fromhex(ct))

# When P == Q => Lambda = (3*(P.x*Q.x) + A*P.x + B) * inverse(P.y+Q.y+C, self.p)
# Lambda = (dy / dx) = (3x^2 + Ax + B) / (2y + C)
# => Curve (E): y^2 + Cy = x^3 + (A/2)x^2 + Bx + D

iv, ct = "baf9137b5bb8fa896ca84ce1a98b34e5", "df572f57ac514eeee9075bc0ff4d946a80cb16a6e8cd3e1bb686fabe543698dd8f62184060aecff758b29d92ed0e5a315579b47f6963260d5d52b7ba00ac47fd"
p = 101177610013690114367644862496650410682060315507552683976670417670408764432851
A = 417826948860567519876089769167830531934//2
B = 177776968102066079765540960971192211603
C = 3045783791
G = (14374457579818477622328740718059855487576640954098578940171165283141210916477, 97329024367170116249091206808639646539802948165666798870051500045258465236698)
D = (G[1]**2 + C*G[1] - G[0]**3 - A*G[0]**2 - B*G[0])%p
F = GF(p)

Pxy = PolynomialRing(F, "x,y"); x, y =Pxy.gens()
E = EllipticCurve(y**2 + C*y - x**3 - A*x**2 - B*x - D)
G = E.point(G)
P = E.lift_x(F(32293793010624418281951109498609822259728115103695057808533313831446479788050))

q = G.order()
factors = factor(q)
Q, N = [], []
for (_pr, _e) in factors[:-2]:
    fac = _pr**_e
    _n = discrete_log(P * (q // fac), G * (q // fac), operation='+', ord=fac)
    Q  += [ZZ(fac)]
    N  += [ZZ(_n)]

_n, m, bound = crt(N, Q), lcm(Q), 38685626227668133590597631
for k in range(bound // m):
    n = _n + k*m
    if n*G == P:
        flag = decrypt(n, iv, ct)
        print(flag)
        exit()