from sage.all import *
from Crypto.PublicKey import RSA
from Crypto.Util.number import *

class LCG:
    def __init__(self, params, seed):
        self.state = seed
        self.lcg_m, self.lcg_c, self.lcg_n = params

    def next(self):
        self.state = (self.state * self.lcg_m + self.lcg_c) % self.lcg_n
        return self.state

def recover_lcg(out):
    s1, s2, s3, s4, s5, s6, s7 = out

    # recover modulus
    tmp1 = (s3 - s2)**2 - (s4 - s3)*(s2 - s1)
    tmp2 = (s4 - s3)**2 - (s5 - s4)*(s3 - s2)
    tmp3 = (s5 - s4)**2 - (s6 - s5)*(s4 - s3)
    n = gcd([tmp1, tmp2, tmp3])

    # recover m, c
    m, c = matrix(Zmod(n), [
        [s1, 1],
        [s2, 1]
    ]).solve_right(vector(Zmod(n), [s2, s3]))
    
    return LCG(seed=s1, params=[int(m), int(c), int(n)])


# import seed from challenge
from chall import seed

# Load dump.txt
with open("./src/dump.txt", "r") as f:
    payload = f.read().replace("\n", ",")
    dump = eval(f"list([{payload}])")

if __name__ == '__main__':
    # Load public key
    key = RSA.importKey(open("./src/public.pem", "r").read())
    N   = key.n
    e   = key.e

    lcg = recover_lcg([seed] + dump)
    primes_arr = []
    primes_n = 1

    while True:
        for i in range(8):
            while True:
                prime_candidate = lcg.next()

                if not isPrime(prime_candidate):
                    continue
                elif prime_candidate.bit_length() != 512:
                    continue
                else:
                    primes_n *= prime_candidate
                    primes_arr.append(prime_candidate)
                    break
        
        # Check bit length
        if primes_n.bit_length() > 4096:
            print("bit length", primes_n.bit_length())
            primes_arr.clear()
            primes_n = 1
            continue
        else:
            break

    # Create public key 'n'
    n = 1
    for j in primes_arr:
        n *= j
    print("[+] Public Key: ", n)
    print("[+] size: ", n.bit_length(), "bits")

    # Calculate totient 'Phi(n)'
    phi = 1
    for k in primes_arr:
        phi *= (k - 1)

    # Calculate private key 'd'
    d = pow(e, -1, phi)

    # Load encrypted flag
    with open ("./src/flag.txt", "rb") as flag_file:
        ct = int.from_bytes(flag_file.read(), "little")
    
    flag = pow(ct, d, n)
    print("Flag: " + long_to_bytes(flag).decode())