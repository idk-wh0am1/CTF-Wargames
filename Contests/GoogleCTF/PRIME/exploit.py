from sage.all import *
from factordb.factordb import FactorDB
from Crypto.Util.number import *
from tqdm import tqdm

# https://tl2cents.github.io/2022/09/05/2022-BalsnCTF-Crypto-Writeup/
def get_factor_list_with_exponent(n):
    if isPrime(n):
        return {n: 1}
    for _ in range(20):
        factor = FactorDB(n)
        factor.connect()
        factor_list = list(factor.get_factor_list())
        if len(factor_list) > 1:
            break
    factor_list_with_exponent = {}
    for factor in factor_list:
        if factor not in factor_list_with_exponent.keys():
            factor_list_with_exponent[factor] = 1
        else:
            factor_list_with_exponent[factor] += 1
    return factor_list_with_exponent

def to_bits(m):
    _bin = lambda b : [1 if b & (1 << n) else 0 for n in range(7)]
    return sum([_bin(b) for b in m], [])

def gen_primes(r, n):
    primes = Primes()[:n]
    bound = prod(primes[n - r:])
    return primes, next_prime(bound)

def prod_exp(p, q, b):
    return prod([p[i]**b[i] for i in range(len(p))]) % q

def encode(r, n, m):
    p, q = gen_primes(r, n)
    return p, q, prod_exp(p, q, to_bits(m))


q = 0xD2F8711CB5502C512ACEA59BE181A8FCF12F183B540D9A6998BF66370F9538F7E39FC507545DAD9AA2E71D3313F0B4408695A0A2C03A790662A9BD01650533C584C90779B73604FB8157F0AB7C9A82E724700E5937D9FF5FCF1EE3BE1EDD7E07B4C0F035A58CC2B9DB8B79F176F595C1B0E90B7957309B96106A50A01B78171599B41C8744BCB1C0E6A24F60AE8946D37F4D4BD8CF286A336E1022996B3BA3918E4D808627D0315BFE291AEB884CBE98BB620DAA735B0467F3287D158231D
X = 0x947062E712C031ADD0B60416D3B87D54B50C1EFBC8DBB87346F960B242AF3DF6DD47406FEC98053A967D28FE91B130FF0FE93689122931F0BA6E73A3E9E6C873B8E2344A459244D1295E99A241E59E1EEA796E9738E6B1EDEED3D91AE6747E8ECA634C030B90B02BAF8AE0088058F6994C7CAC232835AC72D8B23A96F10EF03D74F82C49D4513423DAC298698094B5C631B9C7C62850C498330E9D112BB9CAA574AEE6B0E5E66D5B234B23C755AC1719B4B68133E680A7BCF48B4CFD0924D

m = b"I have a sweet flag for you: CTF{YkDOLIStjpjP5Am1SXDt5d2r9es3b5KZP47v8rXF}"
p, q, Y = encode(131, 7*len(m), m)

E = X * pow(Y, -1, q) % q
convergents = continued_fraction(ZZ(E) / ZZ(q)).convergents()
for c in tqdm(convergents):
    k = ZZ(c.denominator())
    N = E * k % q

    f1 = get_factor_list_with_exponent(int(N)).keys()
    f2 = get_factor_list_with_exponent(int(k)).keys()
    e = list(f1) + list(f2)
    if max(e) in p:
        flag = to_bits(m)
        for  id in e:
            flag[p.index(id)] ^= 1

        flag = [int("".join([str(x) for x in flag[i:i+7]])[::-1], 2) for i in range(0, len(flag), 7)]
        print(bytes(flag))
        break