from pwn import remote
from os import urandom
from hashlib import sha256

def bytes_to_hexstr(buf):
  return "".join(["{0:02X}".format(b) for b in buf])
def bytes_to_int(buf):
  return int(bytes_to_hexstr(buf), 16)
def random_int(n):
  return bytes_to_int(urandom(n))
def sha256_as_int(x):
  return int(sha256(x).hexdigest(), 16)
def check_type(x, types):
  if len(x) != len(types):
    return False
  for a,b in zip(x, types):
    if not isinstance(a, b):
      return False
  return True

class Curve:
  def __init__(self, p, D, n):
    self.p = p
    self.D = D
    self.n = n
  def __repr__(self):
    return f"Curve(0x{self.p:X}, 0x{self.D:X})"
  def __eq__(self, other):
    return self.p == other.p and self.D == other.D
  def __matmul__(self, other):
    assert(check_type(other, (int, int)))
    assert(other[0]**2 % self.p == (self.D*other[1]**2 + 1) % self.p)
    return Point(self, *other)

class Point:
  def __init__(self, C, x, y):
    assert(isinstance(C, Curve))
    self.C = C
    self.x = x
    self.y = y
  def __repr__(self):
    return f"(0x{self.x:X}, 0x{self.y:X})"
  def __eq__(self, other):
    assert(self.C == other.C)
    return self.x == other.x and self.y == other.y
  def __add__(self, other):
    assert(self.C == other.C)
    x0, y0 = self.x, self.y
    x1, y1 = other.x, other.y
    return Point(self.C, (x0*x1 + self.C.D*y0*y1) % self.C.p, (x0*y1 + x1*y0) % self.C.p)
  def __rmul__(self, n):
    assert(check_type((n,), (int,)))
    P = self.C @ (1, 0)
    Q = self
    while n:
      if n & 1:
        P = P + Q
      Q = Q + Q
      n >>= 1
    return P
  def to_bytes(self):
    l = len(hex(self.C.p)[2:])
    return self.x.to_bytes(l, "big") + self.y.to_bytes(l, "big")

class Pub:
  def __init__(self, G, P):
    self.G = G
    self.P = P
  def verify(self, m, sig):
    assert(check_type(sig, (Point, int)))
    (R, s) = sig
    e = sha256_as_int(R.to_bytes() + self.P.to_bytes() + m) % self.G.C.n
    return s*self.G == R + e*self.P

class Priv:
  def __init__(self, k, G):
    self.k = k
    self.G = G
    self.P = k*G
  def get_pub(self):
    return Pub(self.G, self.P)
  def sign(self, m):
    r = random_int(16) % self.G.C.n
    R = r*self.G
    e = sha256_as_int(R.to_bytes() + self.P.to_bytes() + m) % self.G.C.n
    return (R, (r + self.k*e) % self.G.C.n)

p = 0x34096DC6CE88B7D7CB09DE1FEC1EDF9B448D4BE9E341A9F6DC696EF4E4E213B3
D = 0x3
C = Curve(p, D, p-1)
G = C @ (0x2, 0x1)
PRIVATE_KEY = 597042838662739992479017662198571932571177156379622917145185173378909836425
P  = PRIVATE_KEY*G
_P = (0x2FE4D1B7BA0F64D6E5BD5E4E8D55E898FF13B76974646D97BFDCD9DC688C0E2F,
      0x8C33E2FC2957EFF24DD1CD5382169C3BFAAC2E75A900D322A8C84D3C641A27E)

io = remote("cursved.2023.ctfcompetition.com", 1337)
io.recvline()
io.recvline()

nonce   = bytes.fromhex(io.recvline(0).decode().split(' = ')[-1].lower())
priv    = Priv(PRIVATE_KEY, G)
R, s    = priv.sign(nonce)
payload = ' '.join(map(str, [R.  x, R.y, s]))

io.sendlineafter(b" = ", payload.encode())
io.interactive()