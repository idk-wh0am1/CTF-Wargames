from sage.all import *
from Crypto.Util.number import *

e = 62049276217882784669123481609107580132692003506222933469477011716210229840120510933828545556186517488299332289552186988112386430225292481512710648590879066147972603089423274617090784063715618592863267218241749239403902260799735534932202425082174772453067901364109010478700971594591982683359059474940049601129
n = 115770905406500763677927235090067097605478213357173318019374774697762205139769793414784529111832912666064205862330986815882657773547531873208403910272124037534266502074486947075521583641940773096931382846361307562495431049629196174487376183980259415898746225186082208244807639203181099237585968047075726360311
c = 98776629589181855876840400567583479101252206934885913849390290206604565993418996378419986612289948336727854724939233543707899664437740154967965351606927043697584421941603261661959270176907794111596886346256599262408627078411241253359983233308763698939843256953434654728056870133027960127284432352343871098902

# https://github.com/jvdsn/crypto-attacks/blob/master/attacks/rsa/wiener_attack.py
def attack(N, e, ct):
    """
    Recovers the prime factors of a modulus and the private exponent if the private exponent is too small.
    :param N: the modulus
    :param e: the public exponent
    :return: a tuple containing the prime factors and the private exponent, or None if the private exponent was not found
    """
    convergents = continued_fraction(ZZ(e) / ZZ(N)).convergents()
    for c in convergents:
        k = c.numerator()
        d = c.denominator()
        if pow(pow(2, e, N), d, N) != 2:
            continue

        phi = (e * d - 1) // k
        d = inverse(e, phi)

        m = pow(ct, ZZ(d), N)
        flag = long_to_bytes(ZZ(m))
        if b'picoCTF{' in flag:
            print(flag)
            return

attack(n, e, c)